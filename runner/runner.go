package runner

import (
	"bufio"
	"bytes"
	"crypto/md5"
	"encoding/gob"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"sync"
	"syscall"
	"time"
)

var STDPIPE = make(chan []byte)

// ------------------------- ServiceQ -------------------------
type Runner struct {
	id                   string       // id of the runner. md5(epoch+sysCmd)
	isConsole            bool         // if set to true then the shell's commands output is printed on console. default=false
	timeout              int          // maximum duration (in seconds) the system call has before declearing failed. default=0
	waitingPeriod        int          // number of seconds the runner waits before executing the system call. default=0
	logFile              string       // specifiy a file to write logs. if  set to "" then no log files will be written. default=""
	execuitedAt          int64        // epoch then the system call was execuited
	executionTimeNano    int64        // units of nano seconds ellapsed since the system call has started. default=0
	verificationPhrase   string       // if this string is found the in the log then that means the output is vefified, and now the status becomes SUCCESSFUL. default="" that means verification is disabled and now the status can become FINISHED
	status               string       // PENDING | RUNNING | COMPLETED | FAILED | TIMEDOUT | SUCCEEDED | KILLED. default=PENDING. [default=PENDING, COMPLETED => the exitcode of the system call was 0, FAILED => non-zero, SUCCESSFUL => the verification string was found]
	sysCmd               string       // the system command to be execuited. e.g. "ls -al | grep foo". Required
	logBuffer            []byte       // stdout of the system call is kept here. default="", max=1MB
	cmd                  *exec.Cmd    // This is the command variable from exec package
	onNewLogLineCallback func([]byte) // User-defined function to be called when a new output line is generated by the system call and is injected into this function
	onSuccessCallback    func([]byte) // This function gets called when the system call is execuited and the verification phrase is found in the stdout
	onCompleteCallback   func([]byte) // This function gets called when the system call execution completes with exit code '0'. The output of the system call will be injected in the callback function
	onFailCallback       func([]byte) // This function get called when the system call exits with a non-zero exit code. The stdout of the system call is injected into the callback function
	onTimeoutCallback    func([]byte) // This function gets called when the system call took more than the defined timeout duration.
}

// ----------------------- constructor -----------------------
func NewRunner(cmd string) *Runner {
	// TODO take a second optional string parameter. if that is set to "RUN_ONCE" then this function's behaviour will be modified and
	// initialize a runner with default settings and a system command
	r := &Runner{}
	r.id = calculateMD5([]byte(fmt.Sprintf("%v", time.Now().UnixNano()) + cmd)[:]) // md5 (current_epoch + name)
	r.sysCmd = cmd
	r.status = "PENDING"
	return r
}

// enable console print
func (r *Runner) EnableConsole() {
	r.isConsole = true
}

func (r *Runner) DisableConsole() {
	r.isConsole = false
}

func (r *Runner) SetTimeout(timeout int) {
	r.timeout = timeout
}

// if set then the rinner will wait that much seconds before execuiting the system call. default=0
func (r *Runner) SetWaitingPeriod(wp int) {
	if wp > 0 {
		r.waitingPeriod = wp
	}
}

// provide a filename for log.
func (r *Runner) SetLogFile(file string) {
	r.logFile = file
}

// if verification phrase is provided, then the runner finds the phrase in the output of the system call
// if found then, the status will become 'SUCCEEDED'
func (r *Runner) SetVerificationPhrase(phrase string) {
	r.verificationPhrase = phrase
}

// use this method to attach an user-defined callback function that will be invoked everytime a new line is generated by the system call. The new line will also be injected into the callback function
func (r *Runner) SetOnNewLineCallback(callback func([]byte)) {
	r.onNewLogLineCallback = callback
}

// use this method to attach an user-defined callback function that will be invoked when a system call completes and the verification phrase is present in the output of the system call. Also the stdout of the system call will be injected into the callback fucntion
func (r *Runner) SetOnSuccessCallback(callback func([]byte)) {
	r.onSuccessCallback = callback
}

// use this method to attach an user-defined callback function that will be invoked when a system call completes with an exit code of '0'. Also the stdout of the system call will be injected into the callback fucntion
func (r *Runner) SetOnCompleteCallback(callback func([]byte)) {
	r.onCompleteCallback = callback
}

// use this method to attach an user-defined callback function that will be invoked when a system call exits with a non-zero exit code. Also the stdout of the system call will be injected into the callback fucntion
func (r *Runner) SetOnFailCallback(callback func([]byte)) {
	r.onFailCallback = callback
}

// use this method to attach an user-defined callback function that will be invoked when a system call execution exceeds the defined timeout duration. Also the stdout of the system call will be injected into the callback fucntion
func (r *Runner) SetOnTimeoutCallback(callback func([]byte)) {
	r.onTimeoutCallback = callback
}

// get runner settings.
func (r *Runner) GetState() map[string]interface{} {
	var logSize = len(r.logBuffer)
	return map[string]interface{}{
		"id":                  r.id,
		"console":             r.isConsole,
		"timeout":             r.timeout,
		"waiting_period":      r.waitingPeriod,
		"file_path":           r.logFile,
		"execuited_at":        r.execuitedAt,
		"execution_time_nano": r.executionTimeNano,
		"verification_phrase": r.verificationPhrase,
		"status":              r.status,
		"system_command":      r.sysCmd,
		"log_size_bytes":      logSize,
	}
}

// get status: PENDING | RUNNING | COMPLETED | FAILED | TIMEDOUT | SUCCEEDED | KILLED
func (r *Runner) GetStatus() string {
	return r.status
}

func (r *Runner) ClearLog() {
	r.logBuffer = []byte{}
}

// execute the system call
func (r *Runner) Execute(commands ...string) ([]byte, error) {
	// if multiple strings arguments are provided, then concat that with &&. e.g. <cmd1> && <cmd2> && ...<cmd-n>
	var command string
	if len(commands) > 0 {
		command = strings.Join(commands, " && ")
	} else {
		command = r.sysCmd
	}

	// if weighting period is non zero
	if r.waitingPeriod > 0 {
		time.Sleep(time.Second * time.Duration(r.waitingPeriod))

	}

	// instantiate a command variable (to be run with bash)
	r.cmd = exec.Command("bash", "-c", command)
	r.sysCmd = command

	// set commands STDOUT to the STDOUT of the system
	stdout, err := r.cmd.StdoutPipe()
	if err != nil {
		return []byte{}, err
	}

	var file *os.File
	// Open the file in append mode
	if r.logFile != "" { // TODO check if a proper file or /path/to/file
		file, err = os.OpenFile(r.logFile, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
		if err != nil {
			fmt.Println("Error opening file:", err)
			return []byte{}, err
		}
		defer file.Close()
	}

	// Create a wait group to synchronize goroutines
	var wg sync.WaitGroup

	// instantiate a scanner object. will read command's output stream from here
	scanner := bufio.NewScanner(stdout)

	wg.Add(1)
	go func() {
		defer wg.Done()

		if r.logFile != "" {
			_, err := file.WriteString("[" + strconv.Itoa(int(time.Now().UnixMicro())) + "]" + " command" + "\n```shell\n" + r.sysCmd + "\n```\n\n" + "[" + strconv.Itoa(int(time.Now().UnixMicro())) + "]" + " Response begin\n```shell\n")
			if err != nil {
				fmt.Println("Error writing to file:", err)
				return
			}
		}

		// read each stdout line in each iteration
		for scanner.Scan() {
			stdoutLine := scanner.Text()

			r.logBuffer = append(r.logBuffer, scanner.Bytes()...)
			r.logBuffer = append(r.logBuffer, '\n')

			// write to a file here
			if r.logFile != "" {
				_, err := file.WriteString(stdoutLine + "\n")
				if err != nil {
					fmt.Println("Error writing to file:", err)
					return
				}
			}

			// print to console
			if r.isConsole {
				fmt.Println(stdoutLine)
			}

			// if callback function is attached, then invoke that while injecting the new stdout line into it
			if r.onNewLogLineCallback != nil {
				r.onNewLogLineCallback(scanner.Bytes()) // Invoke the user-defined success callback
			}
		}

		// write footer after command is executed
		if r.logFile != "" {
			_, err := file.WriteString("```\n" + "[" + strconv.Itoa(int(time.Now().UnixMicro())) + "]" + " Response end\n" + "---\n")
			if err != nil {
				fmt.Println("Error writing to file:", err)
				return
			}
		}
	}()

	// Execute the command
	r.logBuffer = []byte{} // reset the log buffer
	r.status = "RUNNING"
	r.execuitedAt = time.Now().UnixNano()
	if err := r.cmd.Start(); err != nil {
		return []byte{}, err
	}

	done := make(chan struct{})
	go func() {
		r.cmd.Wait()
		close(done)
	}()

	// Let's simulate a timeout
	timeout := time.After(10 * time.Second)

	select {
	case <-done:
		// Process completed successfully
	case <-timeout:
		// Timeout occurred, terminate the process
		if r.cmd.Process != nil {
			fmt.Println("Timeout, terminating the process...")
			err := r.cmd.Process.Signal(syscall.SIGKILL)
			r.status = "TIMEDOUT"
			if err != nil {
				fmt.Println("Error terminating the process:", err)
			}
		}
	}
	// Wait for the system call to finish
	// err = cmd.Wait()
	r.executionTimeNano = time.Now().UnixNano() - r.execuitedAt

	// capture the exit code of the system call
	exitCode := r.cmd.ProcessState.ExitCode()

	// Wait for all goroutines (file-logger + console-logger) finish before returning
	wg.Wait()

	// early exit if failed
	if r.status == "KILLED" {
		return r.logBuffer, nil
	}

	if r.status == "TIMEDOUT" {
		// if attached, then invoke the onTimeoutCallback() function
		if r.onTimeoutCallback != nil {
			r.onNewLogLineCallback(r.logBuffer) // Invoke the user-defined success callback
		}
		return r.logBuffer, nil
	}

	// search and match output and set status to VERIFIED
	if r.verificationPhrase != "" && strings.Contains(string(r.logBuffer), r.verificationPhrase) {
		// if attached, then invoke the onSuccessCallback() function
		if r.onSuccessCallback != nil {
			r.onSuccessCallback(r.logBuffer) // Invoke the user-defined success callback
		}
		r.status = "SUCCEEDED"
		return r.logBuffer, nil
	}

	// if success, update status based on exit code
	if exitCode == 0 {
		r.status = "COMPLETED"
		// if attached, then invoke the onCompleteCallback() function
		if r.onSuccessCallback != nil {
			r.onCompleteCallback(r.logBuffer) // callbacl
		}
		return r.logBuffer, nil
	}

	// ATP: the system call exited with a non-zero exit code
	r.status = "FAILED"
	// if attached, then invoke the onCompleteCallback() function
	if r.onFailCallback != nil {
		r.onCompleteCallback(r.logBuffer) // callback
	}
	return r.logBuffer, nil
}

// read logs buffer
func (r *Runner) Logs() string {
	return string(r.logBuffer)
}

// clear logs buffer
func (r *Runner) ClearLogs() {
	r.logBuffer = []byte{}
}

// reexecute the runner
func (r *Runner) Restart() {
	// TODO
}

func (r *Runner) Kill() {
	// kill on-demand
	// TODO: Move it into a new method
	if r.cmd.Process != nil {
		fmt.Println("Terminating process...")
		err := r.cmd.Process.Kill()
		r.status = "KILLED"
		if err != nil {
			fmt.Println("Error killing process:", err)
		}
	}
}

// ----------------------- utility ---------------------------------
func calculateMD5(data interface{}) string {
	var buffer bytes.Buffer
	encoder := gob.NewEncoder(&buffer)
	err := encoder.Encode(data)
	if err != nil {
		panic(err)
	}
	hash := md5.Sum(buffer.Bytes())
	return hex.EncodeToString(hash[:])
}
